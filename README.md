# Intern-Game-Logic-Programmer-Test

## №1
<details>
  <summary>Описание задачи</summary>

  На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 
```python
def isEven(value):

      return value % 2 == 0
```

</details>

[Мой код](https://github.com/ego-fm/Intern-Game-Logic-Programmer-Test/blob/main/isEven.py)

**Сравнение реализаций:**

1. ```python
   def isEven(value):
     return value % 2 == 0
   ```

2. ```python
   def is_even(value):
     return (value & 1) == 0
   ```

**1 Вариант (остаток от деления):**

  Плюсы: Очевидность работы алгоритма, понятная любому программисту.
  
  Минусы: Уступает в скорости реализации на побитовой операции &(AND).

**2 Вариант (побитовое И):**

  Плюсы: Лучшая производительность, так как побитовая операция & работает быстрее чем операция получения остатка от деления.
  
  Минусы: Не самый очевидный принцип работы алгоритма, может запутать начинающего программиста.


## №2

<details>
  <summary>Условие задания</summary>

На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

</details>

[Реализация 1: На массиве с управлением индексами](https://github.com/ego-fm/Intern-Game-Logic-Programmer-Test/blob/main/fifoBuffer/CircularBufferList.py)

[Реализация 2: На базе collections.deque](https://github.com/ego-fm/Intern-Game-Logic-Programmer-Test/blob/main/fifoBuffer/CircularBufferDeque.py)


| Критерий | CircularBufferList | CircularBufferDeque |
| --- | --- | --- |
| Используемая структура | Массив фиксированной длины | Коллекция deque из модуля collections |
| Простота реализации | Реализация сложнее из-за ручного управления указателями | Реализация проще благодаря встроенным методам |
| Скорость операций | Константное время O(1) для вставки / удаления, но есть небольшие накладные расходы на управление указателями | Константное время O(1) для вставки / удаления, благодаря оптимизации deque |
| Использование памяти | Более компактно, так как использует фиксированный массив | deque использует больше памяти для служебных данных |


## №3

<details>
  <summary>Условие задания</summary>

На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

</details>


[Реализация поразрядной сортировки](https://github.com/ego-fm/Intern-Game-Logic-Programmer-Test/blob/main/sort.py)

Поразрядная сортировка (radix sort) — алгоритм сортировки, который выполняется за линейное время.

Если необходимо максимизировать скорость сортировки чисел можно использовать этот алгоритм, он обладает линейной сложностью O(n), если считать максимальное количество разрядов константой, но узкоприменим, только для объектов, которые можно поделить на разряды (моя реализация подходит для целых чисел).


Если же нужен более универсальный алгоритм, при малой потере производительности в среднем случае, лучше всего использовать Timsort (используется в sorted() и .sort() в Python).

Timsort — гибридный алгоритм (сортировка вставками + слиянием), со средней сложностью O(n log n), и с приростом производительности для частично отсортированных массивов, вплоть до O(n), если массив уже отсортирован полностью.
